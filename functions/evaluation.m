function [AUC, AUROC, rec, prec, fpr] = evaluation(res, GS,varargin)
%
% This function evaluates the accuracy of a prediction compared
% to a gold standard.
%
%
% INPUTS:
%	res:	estimated adj network
%	GS: 	true network
%
% OUTPUTS:
%	AUC:		area under the precision-recall curve (also called AUPR)
%	AUROC:		area under the ROC curve
%   rec:    RECALL
%   prec:   PRECISION
%   fpr:    FALSE POSITIVE RATIO
% All further information about the actual calculations can be found elsewhere.

% The algorithm was developed by Gustavo Stolovitzky and implemented by
% Bernd Jagla, Columbia University (baj2107_A_T_columbia.edu).
% All questions/suggestions should be directed to both, Gustavo and Bernd.
%
% Gustavo A. Stolovitzky, Ph.D.
% Adj. Assoc Prof of Biomed Informatics, Columbia Univ
% Mngr, Func Genomics & Sys Biology, IBM  Research
% P.O.Box 218 					Office :  (914) 945-1292
% Yorktown Heights, NY 10598 	Fax     :  (914) 945-4217
% http://www.research.ibm.com/people/g/gustavo
% http://domino.research.ibm.com/comm/research_projects.nsf/pages/fungen.index.html
%
% Bernd Jagla, Ph.D.
% Assoc. Rsch. Scientist
% Joint Centers for Systems Biology
% Columbia University
% Irving Cancer Res Ctr
% 1130 St Nicholas Avenue 8th Floor
% United States
%
% Robert Prill, Ph.D.
% Post-doctoral Researcher
% Computational Biology Center, IBM Research
% P.O.Box 218
% Yorktown Heights, NY 10598
% Office :  914-945-1377
% http://www.research.ibm.com/people/r/rjprill/
%
%
% The original script has been modified to make it compatible with gold standard
% files generated by GeneNetWeaver (gnw.sf.net), i.e. compatible with gold standard
% files that do not contain null-interactions. Besides, PR and ROC curves are
% now plotted. Extension made on December 2008 by:
%
% Thomas Schaffter, Ph.D. Student
% Ecole Polytechnique Federale de Lausanne (EPFL)
% Laboratory of Intelligent Systems (LIS)
% CH-1015 Lausanne, Switzerland
% http://lis.epfl.ch/member.php?SCIPER=161219
%
% The Original code from GNW
% http://gnw.sourceforge.net/genenetweaver.html
% Code covered by the MIT License
%
% The original script has been modified.
% Modification made on Nov. 2012 by:
%
% Shinya Tasaki, Ph.D.


num_bin =0;
plot_on = 0;
args = varargin;
nargs = length(args);

for i=1:2:nargs
    switch args{i},
        case 'nbin',   num_bin = args{i+1}; %nsamples=100
        case 'plot', plot_on = args{i+1};
    end
end


res=setdiag(res,0);
GS=setdiag(GS,0)~=0;
% Total number of edges in the network
T = length(GS).^2 - length(GS);
% Number of interactions defined in the goldstandard
P = length(find(GS));
% Number of interactions with null weight
N = T-P; %N = length(gold{1}) - P
% Number of interactions predicted
L = length(find(res));


if num_bin ==0
    [ai, bi, ci]=find(res);
    [~,bbi]=sort(ci,'descend');
    ai=ai(bbi);
    bi=bi(bbi);
    clear bbi aai;
    
    rec=zeros(1,length(ai)); % RECALL
    prec = rec; % PRECISION
    fpr =rec; % FALSE POSITIVE RATIO
    pered = fpr;
    
    TPk=0;% TRUE POSITIVE number
    FPk=0;% FALSE POSTIVE number
    for i=1:length(ai)
        %     net=[ai(i),bi(i)];
        if GS(ai(i),bi(i))
            TPk=TPk+1;
        else
            FPk=FPk+1;
        end
        pered(i)=1-i/T;
        rec(i) = TPk; % RECALL = TRUE POSITIVE num / num edges
        prec(i) = TPk/i; % PRECISION = TRUPOSITIVE num / Predicted edge num
        fpr(i)=FPk;
    end
else
    
    thvec =max(res(:))-(max(res(:))-min(res(:)))/num_bin:-(max(res(:))-min(res(:)))/num_bin:min(res(:));
    rec=zeros(1,length(thvec)); % RECALL
    prec = rec; % PRECISION
    fpr =rec; % FALSE POSITIVE RATIO
    pered = fpr;
    TPk=0;% TRUE POSITIVE number
    for i=1:length(thvec)
        net = res>thvec(i);
        TPk=length(find(net&GS));
        npe = sum(net(:));
        rec(i) = TPk; % RECALL = TRUE POSITIVE num / num edges
        prec(i) = TPk/npe; % PRECISION = TRUPOSITIVE num / Predicted edge num
        fpr(i)=npe-TPk;
        pered(i)=1-npe/T;
    end
end
rec = rec./P;
fpr=fpr./N;
tpr = rec; % TRUE POSITIVE RATIO
%% assume random accuracy for remainder of links
TPL=TPk;
if L < T %Number of interactions predicted<Total number of edges in the network
    rh = (P-TPL)/(T-L);
else
    rh = 0;
end

if L>0
    recL = rec(end);
else
    recL = 0;
end

while TPk < P
    i = i + 1;
    TPk = TPk + 1;
    rec(i) = TPk/P;
    if ((rec(i)-recL)*P + L * rh) ~= 0
        prec(i) = rh * P * rec(i)/((rec(i)-recL)*P + L * rh);
    else
        prec(i) = 0;
    end
    tpr(i) = rec(i);
    FPk = TPk * (1-prec(i))/prec(i);
    fpr(i) = FPk/N;
end

%Integrate area under PR
AUC = rec(1)*prec(1);
for n=1:length(rec)-1
    AUC = AUC + (rec(n+1)-rec(n)) * (prec(n+1)+prec(n)) / 2;
end

%Integrate area under ROC
lc = fpr(1) * tpr(1) /2;
for n=1:length(fpr)-1
    lc = lc + (fpr(n+1)+fpr(n)) * (tpr(n+1)-tpr(n)) / 2;
end
AUROC = 1 - lc;

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Display PR and ROC curves
if plot_on==1
    subplot(2,1,1);
    shadedCurve(rec,prec);
    title(['AUPR = ' sprintf('%f', AUC)]);
    xlabel('Recall');
    ylabel('Precision');
    
    subplot(2,1,2);
    shadedCurve(fpr,tpr);
    title(['AUROC = ' sprintf('%f', AUROC)]);
    xlabel('False Positive Rate');
    ylabel('True Positive Rate');
    set(gcf,'color',[1 1 1]);
end
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Helper functions

end

% Plot a shaded curve
function shadedCurve(X,Y)
R = 141/255;
G = 182/255;
B = 243/255;
n = length(X);
x = [1 1 0 0 X];
y = [Y(n) 0 0 Y(1) Y];
plot(x,y,'LineWidth',1,'Color',[0 0 0]);
h = fill(x,y,[R G B]);
set(h,'FaceAlpha',0.6);
axis([0 1 0 1]);
axis square;
end


